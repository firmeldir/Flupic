package com.example.flupic.util

import android.graphics.drawable.Drawable
import android.net.Uri
import android.util.Log
import android.view.KeyEvent
import android.view.View
import android.view.inputmethod.EditorInfo
import android.widget.EditText
import android.widget.ImageView
import android.widget.TextView
import androidx.core.net.toUri
import androidx.core.text.HtmlCompat
import androidx.databinding.BindingAdapter
import androidx.fragment.app.Fragment
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.*
import coil.api.load
import coil.transform.CircleCropTransformation
import com.example.flupic.model.User
import com.example.flupic.result.Event
import com.example.flupic.result.EventObserver
import com.example.flupic.result.Result
import com.example.flupic.util.view.FadingSnackbar
import com.example.flupic.util.view.SnackbarMessage
import com.example.flupic.util.view.SnackbarMessageManager
import com.google.android.gms.auth.api.credentials.Credential
import com.google.firebase.auth.FirebaseUser
import me.zhanghai.android.materialprogressbar.MaterialProgressBar

/**
 * For Fragments, allows declarations like
 * ```
 * val myViewModel = viewModelProvider(myViewModelFactory)
 * ```
 */
inline fun <reified VM : ViewModel> Fragment.viewModelProvider(
    provider: ViewModelProvider.Factory
) =
    ViewModelProvider(this, provider).get(VM::class.java)


inline fun <reified VM : ViewModel> FragmentActivity.viewModelProvider(
    provider: ViewModelProvider.Factory
) =
    ViewModelProvider(this, provider).get(VM::class.java)


fun EditText.setImeOnDoneListener(onDonePressed: () -> Unit){
    this.setOnEditorActionListener { _, actionId, event ->

        if (event != null && event.keyCode == KeyEvent.KEYCODE_ENTER) {
            if (event.action == KeyEvent.ACTION_UP)
                onDonePressed()

            return@setOnEditorActionListener true

        } else if (actionId == EditorInfo.IME_ACTION_DONE) {
            onDonePressed()

            return@setOnEditorActionListener true
        }
        return@setOnEditorActionListener false
    }
}

fun EditText.getValidPhoneNumberOr(or: String? = null): String?
        = this.text?.toString() ?: or

fun EditText.getValidUsernameOr(or: String? = null): String?{
    val username = this.text?.toString() ?: or

    if(username?.length in 7..20)
        return username

    return null
}


fun String.formatPhoneNumberUsingCountryCode(countyCode: String): String
        = if (this.startsWith("+")) this
        else ("+" + countyCode + this.replace("[^\\d.]".toRegex(), ""))

fun buildCredential(user: FirebaseUser?, password: String?, accountType: String?): Credential?{ //TODO Refactor to Beauty

    val email = user?.email
    val phone = user?.phoneNumber
    val profilePictureUri = user?.photoUrl?.toString()?.toUri()

    if(email == null && phone == null)return null

    if(password == null && accountType == null)return null

    val builder = Credential.Builder(
        if(email.isNullOrEmpty()) { phone } else { email }
    ).setName(user.displayName)
        .setProfilePictureUri(profilePictureUri)

    if(password.isNullOrEmpty()) builder.setAccountType(accountType)
        else builder.setPassword(password)

    return builder.build()
}

fun Fragment.setUpSnackbar(
    snackbarMessage: LiveData<Event<SnackbarMessage>>,
    fadingSnackbar: FadingSnackbar,
    snackbarMessageManager: SnackbarMessageManager,
    actionClickListener: () -> Unit = {}
) {
    // Show messages generated by the ViewModel
    snackbarMessage.observe(this, EventObserver { message: SnackbarMessage ->
        fadingSnackbar.show(
            messageId = message.messageId,
            actionId = message.actionId,
            longDuration = message.longDuration,
            actionClick = {
                actionClickListener()
                fadingSnackbar.dismiss()
            }
        )
    })

    // Important reservations messages are handled with a message manager
    snackbarMessageManager.observeNextMessage().observe(this, EventObserver { message ->
        val messageText = HtmlCompat.fromHtml(
            requireContext().getString(message.messageId),
            HtmlCompat.FROM_HTML_MODE_LEGACY
        )
        fadingSnackbar.show(
            messageText = messageText,
            actionId = message.actionId,
            longDuration = message.longDuration,
            actionClick = {
                actionClickListener()
                fadingSnackbar.dismiss()
            },
            // When the snackbar is dismissed, ping the snackbar message manager in case there
            // are pending messages.
            dismissListener = { snackbarMessageManager.loadNextMessage() }
        )
    })
}

/** Uses `Transformations.map` on a LiveData */
fun <X, Y> LiveData<X>.map(body: (X) -> Y): LiveData<Y> {
    return Transformations.map(this, body)
}

fun <A, B, Result> LiveData<A>.combine(
    other: LiveData<B>,
    combiner: (A, B) -> Result
): LiveData<Result> {
    val result = MediatorLiveData<Result>()
    result.addSource(this) { a ->
        val b = other.value
        if (b != null) {
            result.postValue(combiner(a, b))
        }
    }
    result.addSource(other) { b ->
        val a = this@combine.value
        if (a != null) {
            result.postValue(combiner(a, b))
        }
    }
    return result
}

fun <A> LiveData<Result<A>>.uniteSuccessResults(
    other: LiveData<Result<A>>
): LiveData<A> {
    val result = MediatorLiveData<A>()

    result.addSource(this) { a ->
        if(a is Result.Success)
            result.postValue(a.data)
    }
    result.addSource(other) { b ->
        if(b is Result.Success)
            result.postValue(b.data)
    }
    return result
}

@BindingAdapter(value = ["setCircleImageByUrl", "placeholder"], requireAll = false)
fun ImageView.setCircleImageByUrl(photoUrl: String?, placeholder: Drawable?)
{
    if(!photoUrl.isNullOrEmpty()){
        this.load(photoUrl) {
            crossfade(true)
            transformations(CircleCropTransformation())
            placeholder(placeholder)
        }
    }else{
        this.load(placeholder) {
            crossfade(true)
            transformations(CircleCropTransformation())
        }
    }
}

fun Fragment.animate() = this.view?.animate()

@BindingAdapter("onLoading")
fun MaterialProgressBar.onLoading(boolean: Boolean?){
    this.visibility = if(boolean == true) View.VISIBLE else View.GONE
}

@BindingAdapter("disappearingText")
fun TextView.disappearingText(string: String?){
    this.visibility = if(string?.isEmpty() == true) View.GONE else View.VISIBLE
}

@BindingAdapter("nameElseUsername")
fun TextView.nameElseUsername(user: User?){
    if(user != null){
        this.text = if(user.name.isEmpty())user.username
        else user.name
    }
}

